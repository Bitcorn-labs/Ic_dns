import Array "mo:base/Array";
import Buffer "mo:base/Buffer";
import Blob "mo:base/Blob";
import D "mo:base/Debug";
import Error "mo:base/Error";
import ExperimentalCycles "mo:base/ExperimentalCycles";

import Int "mo:base/Int";
import Iter "mo:base/Iter";
import Principal "mo:base/Principal";
import Nat32 "mo:base/Nat32";
import Nat64 "mo:base/Nat64";
import Result "mo:base/Result";
import Time "mo:base/Time";
import Timer "mo:base/Timer";
import Text "mo:base/Text";
import AccountLib "mo:account";

import Nat "mo:base/Nat";
import CertTree "mo:cert/CertTree";

import ICRC1 "mo:icrc1-mo/ICRC1";
import ICRC2Service "mo:icrc2-mo/ICRC2/service";
import ICRC2 "mo:icrc2-mo/ICRC2";
import ICRC3 "mo:icrc3-mo/";
import ICRC3Helper "mo:icrc3-mo/helper";
import ICRC4 "mo:icrc4-mo/ICRC4";
import Sha256 "mo:sha2/Sha256";
import PExt "mo:principal-ext";


import CyclesLedger "CycleLedger";
import CMC "cmc";
import ICRC75 "mo:icrc75-mo";
import Service75 "mo:icrc75-mo/service";
import TTTypes "mo:timer-tool/migrations/types";

shared ({ caller = _owner }) actor class Token  (args: ?{
    icrc1 : ?ICRC1.InitArgs;
    icrc2 : ?ICRC2.InitArgs;
    icrc3 : ICRC3.InitArgs; //already typed nullable
    icrc4 : ?ICRC4.InitArgs;
    icrc75 : ICRC75.InitArgs;
  }
) = this{

    let debug_channel = {
      announce = true;
      rate = true;
      share = true;
      namespace = true;
    };



  public shared(msg) func icrc86_claim_domain(request: DomainClaimRequest) : async DomainClaimResponse {
    let domain = request.domain;
    if(domain.size() == 0){
      return #Err(#Unauthorized);
    };
    for(thisItem in domain.vals()){
      if(thisItem.size() == 0){
        return #Err(#Unauthorized);
      };
    };
    let controllers = switch(request.controllers){
      case(null){ [msg.caller]};
      case(?val) val;
    };

    let accountToUse = switch(request.gateAccount){
      case(null){
        {
          owner = msg.caller;
          subaccount = null;
        };
      };
      case(?val) val;
    };

    debug if(debug_channel.announce) D.print("account to use" # debug_show(accountToUse));

    if(accountToUse.owner != msg.caller){
      return #Err(#Unauthorized);
    };

    debug if(debug_channel.announce) D.print("claiming domain" # debug_show(domain) # debug_show(controllers) # debug_show(request.validationCode));

    let ownerRecord = ICRC1.Map.get(domainOwners, domainHash, domain);

    switch(ownerRecord){
      case(null){
        //owner record doesn't exist
        debug if(debug_channel.namespace) D.print("owner record doesn't exist");
        switch(request.validationCode){
          case(null){
            let validation = generateValidation();
            
            if(await* gateValidation(controllers, validation, accountToUse)){
              debug if(debug_channel.namespace) D.print("validation passed");
              ignore ICRC1.Map.put(domainValidation, domainHash, domain, {
                validation = validation;
                controllers = controllers;
                approved = false;
                validationTime = Time.now();
                domain = domain;
                });
              return #ValidationRequired{controllers = controllers; existingControllers=null; domain = domain; validation = validation};
            } else {
              debug if(debug_channel.namespace) D.print("validation did not pass");
              return #Err(#ValidationGateFailed);
            };
            
            ignore ICRC1.Map.put(domainValidation, domainHash, domain,  {
                validation = validation;
                controllers = controllers;
                approved = false;
                validationTime = Time.now();
                domain = domain;
                });
            return #ValidationRequired({controllers = controllers; existingControllers = null; domain = domain; validation = validation});
          };
          case(?validation){

            let currentValidtionRecord = ICRC1.Map.get(domainValidation, domainHash, domain);

            switch(currentValidtionRecord){
              case(null){
                //return error that validation record isn't fond
                return #Err(#ValidationRecordNotFound);
              };
              case(?foundValidation){
                if(foundValidation.validation != validation){
                  return #Err(#ValidationRecordNotFound);
                };
                if(foundValidation.approved == true and Array.equal<Principal>(foundValidation.controllers, controllers, Principal.equal)){
                  //update the account
                  ignore ICRC1.Map.put(domainOwners, domainHash, domain, controllers);
                  //todo: move to namespace managment ignore await moveNamespaceBalance(namespace, account);
                  return #Ok({
                    controllers = controllers;
                    domain = domain;
                  });
                };
                return #Err(#ValidationRecordNotApproved);
              };
            };
          }
        };
      };
      case(?val){
        debug if(debug_channel.namespace) D.print("owner record exist");
        switch(request.validationCode){
          case(null){
            //todo: gate validation
            
            let revalidation = generateValidation();
            if(await* gateValidation(controllers, revalidation, accountToUse)){
              ignore ICRC1.Map.put(domainValidation, domainHash, domain, ({
                validation = revalidation;
                controllers = controllers;
                approved = false;
                validationTime = Time.now();
                domain = domain;
              }));
              return #ValidationRequired{domain = domain; existingControllers=null;  validation = revalidation; controllers=controllers};
            } else {
              return #Err(#ValidationGateFailed);
            };
          };
          case(?validation){

            let currentValidtionRecord = ICRC1.Map.get(domainValidation, domainHash, domain);

            switch(currentValidtionRecord){
              case(null){
                //return error that validation record isn't fond
                return #Err(#ValidationRecordNotFound);
              };
              case(?foundValidation){
                if(foundValidation.validation != validation){
                  return #Err(#ValidationRecordNotFound);
                };
                if(foundValidation.approved == true){
                  //update the account
                  ignore ICRC1.Map.put(domainOwners, domainHash, domain, controllers);
                  //todo: move this to the list creation ignore await moveNamespaceBalance(namespace, account);
                  return #Ok({
                    controllers = controllers;
                    domain = request.domain;
                  });
                };
                return #Err(#ValidationRecordNotApproved);
              };
            };
          };
        };
      };
    };
  };

  private func moveNamespaceBalance(namespace: Text, account: ICRC1.Account) : async Nat {
    let source_account = namespace_account(namespace);
    let balance = icrc1().balance_of(source_account);
    let fee : Nat = icrc1().fee();
    if(balance > fee){
      let amount = balance - fee;
      let result =  await* icrc1().transfer(source_account.owner, {
        from_subaccount = source_account.subaccount;
        to = account;
        amount = amount;
        fee = ?fee;
        memo = ?Text.encodeUtf8("claim");
        created_at_time = ?Nat64.fromNat(Int.abs(Time.now()));
      });
      debug if(debug_channel.namespace) D.print("transfer result" # debug_show(result));
      amount;
    } else {
      0;
    };
  };

  //todo: depricate after auto approval
  public shared(msg) func icrc86_approve_domain(request: DomainApprovalRequest) : async DomainApprovalResponse {
    assert(msg.caller == owner);
    let domain = request.domain;
    let validationRecord = ICRC1.Map.get(domainValidation, domainHash, domain);

    switch(validationRecord){
      case(null){
        return #Err(#ValidationRecordNotFound);
      };
      case(?val){
        if(val.validation != request.validationCode){
          return #Err(#ValidationRecordNotFound);
        };
        ignore ICRC1.Map.put(domainValidation, domainHash, domain, {
          val with
          validationTime = Time.now();
          approved = true
        });
        ignore ICRC1.Map.put(domainOwners, domainHash, domain, val.controllers);
        
        return #Ok;
      };
    };
  };

  public query(msg) func icrc86_domain_look_up(domains: [Domain]) : async [(?[Principal], ?DomainValidationRecord)] {
    let results = Buffer.Buffer<(?[Principal], ?DomainValidationRecord)>(1);
    for(domain in domains.vals()){
      let validation = ICRC1.Map.get(domainValidation,domainHash, domain);
      let controllers =  ICRC1.Map.get(domainOwners, domainHash, domain);
      results.add((controllers, validation));
    };

    return Buffer.toArray(results);
  };

  public type NamespaceLookupResponse = {
    domain: Domain;
    controllers: [Principal];
  };

  private func namespace_lookup(namespaces: [[Text]]) : [?NamespaceLookupResponse] {
    var result = Buffer.Buffer<?NamespaceLookupResponse>(1);
    for(namespace in namespaces.vals()){
      //loop that checks if it exists and then removes one item from the end of the namespace
      var domainLevels : [Text] = namespace;
      label search while(domainLevels.size() > 0){
        switch(ICRC1.Map.get(domainOwners, domainHash, domainLevels)){
          case(null){
            if(domainLevels.size() == 1){
              result.add(null);
              break search;
            };
            D.print(debug_show(domainLevels));
            domainLevels := Array.slice<Text>(domainLevels, 0, domainLevels.size() - 1) |>
                            Iter.toArray<Text>(_) ;
            D.print(debug_show(domainLevels));
          };
          case(?val){
            result.add(?{
              domain = domainLevels;
              controllers = val;
            });
            break search;
          };
        };
      };
    };

    return Buffer.toArray(result);
  };

  
  public query(msg) func icrc86_namespace_look_up(namespaces: [[Text]]) : async [?NamespaceLookupResponse] {
    namespace_lookup(namespaces);
  };

  private func valueToAccount(val : ICRC3.Value) : ?ICRC1.Account {
    switch(val){
      case(#Array(val)){
        if(val.size() == 0){
          return null;
        } else if (val.size() == 1){
          switch(val[0]){
            case(#Blob(blob)){
              return ?{
                owner = Principal.fromBlob(blob);
                subaccount = null;
              };
            };
            case(_){
              return null;
            };
          } 
        } else if (val.size() == 2){
            switch(val[0],val[1]){
              case(#Blob(blob), #Blob(blobSA)){
                return ?{
                  owner = Principal.fromBlob(blob);
                  subaccount = ?blobSA;
                };
              };
              case(_,_){
                return null;
              };
            };
        };
      };
      case(_){
        return null;
      };
    };
    return null;
  };


  public shared(msg) func icrc85_deposit_cycles_notify(request: ShareArgs) : () {
    let result = await* process_cycles(msg.caller, request);
    return;
  };

  public shared(msg) func icrc85_deposit_cycles(request: ShareArgs) : async ShareResult {
    return await* process_cycles(msg.caller, request);
  };

  private func process_cycles(caller: Principal, request: ShareArgs) : async* ShareResult {

  
    debug if(debug_channel.announce) D.print("recived cycles");
    
    let amount = ExperimentalCycles.available();
    if(amount <= 100_000_000) return #Err(#NotEnoughCycles(amount, 100_000_000));
    var accepted = amount;
    ignore ExperimentalCycles.accept(accepted);
    debug if(debug_channel.share) D.print("recived cycles" # debug_show(accepted));

    let balance = ExperimentalCycles.balance();

    if(balance < minCycles){
      if(minCycles > accepted + balance){
        //no distribution...take all for canister cycles
        return #Ok(0);
      } else {
        let take = minCycles - balance;
        accepted -= take;
        if(accepted<=100_000_000){
          //no distribution...take all for canister cycles
          return #Ok(0);
        };
      };
    };


    let total = accepted - 100_000_000;
    
    debug if(debug_channel.share) D.print("total " # debug_show(total));

    var shareTotal = 0;
    for (share in request.vals()) {
      let (namespace, shareAmount) = share;
      shareTotal += shareAmount;
    };

    debug if(debug_channel.share) D.print("shareTotal " # debug_show(shareTotal));

    var remaining = shareTotal;
    //Deposit the Cycles
    let cycleLedger : CyclesLedger.Service = actor(CyclesLedger_CANISTER_ID);
    ExperimentalCycles.add(amount);


    debug if(debug_channel.share) D.print("depositing " # debug_show(amount));
    let result = try{
     await cycleLedger.deposit({
        to = {
          owner = Principal.fromActor(this);
          subaccount = null;
        }; 
        memo = null
      });
    } catch(e){
      ICRC1.Vector.add(failedDeposit, (total, request));
      return #Err(#CustomError("Failed to deposit cycles"));
    };
    debug if(debug_channel.share) D.print("depositing result" # debug_show(result));
    
    var amountMinted = 0;
    for (share in request.vals()) {
      let (namespace, shareAmount) = share;
      let namespaceItems = switch(ICRC75.BTree.get(icrc75().get_state().namespaceStore,Text.compare,namespace)){
        case(null) [];
        case(?val) ICRC75.Set.toArray(val.members);
      };

      let (bAccount, possibleAccount : ICRC1.Account) = switch(AccountLib.fromText(namespace)){
        case(#ok(val)) (true, val);
        case(_) (false, {owner = Principal.fromActor(this); subaccount = null});
      };

      let namespaceAccount = if(namespace == ""){
        //abandoned cycles; mint to ICDV
        {owner = Principal.fromText("k3gvh-4fgvt-etjfk-dfpfc-we5bp-cguw5-6rrao-65iwb-ttim7-tt3bc-6qe"); subaccount = null};
      } else if(PExt.fromText(namespace) != null){
        //a principal was provided
        {owner = Principal.fromText(namespace); subaccount = null};
      } else if(bAccount){
        //a account was provided
        possibleAccount;
      } else if(namespaceItems.size() != 1){
        namespace_account(namespace);
      } else {
        switch(namespaceItems[0]){
          case(#Account(val)) val;
          case(_) namespace_account(namespace);
        };
      };

      let thisAmount = (total * shareAmount) / shareTotal; 
      debug if(debug_channel.share) D.print("mint " # debug_show((namespace, namespaceAccount, thisAmount)));
      let mintResult =  await* icrc1().mint(icrc1().minting_account().owner,  {
        to = namespaceAccount;               // The account receiving the newly minted tokens.
        amount =  thisAmount;          // The number of tokens to mint.
        memo = ?Principal.toBlob(caller);               // An optional memo accompanying the minting operation.
        created_at_time = ?Nat64.fromNat(Int.abs(Time.now())); // The time the mint operation was created.
      });

      debug if(debug_channel.share) D.print("mint result" # debug_show(mintResult));
      amountMinted += thisAmount;
    };

    debug if(debug_channel.share) D.print("done minting " # debug_show(amountMinted));

    if(amountMinted < total){
      ignore await* icrc1().mint(icrc1().minting_account().owner,  {
        to = devAccount;               // The account receiving the newly minted tokens.
        amount =  total - amountMinted;          // The number of tokens to mint.
        memo = ?Principal.toBlob(caller);               // An optional memo accompanying the minting operation.
        created_at_time = ?Nat64.fromNat(Int.abs(Time.now())); // The time the mint operation was created.
      })
    };
    debug if(debug_channel.share) D.print("done with a thing " # debug_show(amountMinted));
    #Ok(total);
  };

  

  public type WithdrawResult =  {
    #Ok : {
      txid : Nat;
      amount : Nat;
    };
    #Err :  {
      #InsufficientCredit;
      #AmountBelowMinimum ;
      #CallLedgerError : { message : Text };
    };
  };

  private func withdraw_cycles(request: WithdrawArgs) : async WithdrawResult {
    let result = try{
      let cycleLedger : CyclesLedger.Service = actor(CyclesLedger_CANISTER_ID);
      await cycleLedger.icrc1_transfer({
        from_subaccount = null;
        memo = null;
        created_at_time = ?Nat64.fromNat(Int.abs(Time.now()));
        amount = request.amount;
        fee = ?100_000_000;
        to = request.to;
      });

    } catch(e){
      //mint it back
      ignore await* icrc1().mint(icrc1().minting_account().owner,  {
        to = request.to;               // The account receiving the newly minted tokens.
        amount =  request.amount;          // The number of tokens to mint.
        memo = ?Blob.fromArray([1,1,1,2,2,2,2]);               // An optional memo accompanying the minting operation.
        created_at_time = ?Nat64.fromNat(Int.abs(Time.now())); // The time the mint operation was created.
      });
      return #Err(#CallLedgerError( { message = Error.message(e) }));
    };

    let block = switch(result){
      case(#Ok(val)) val;
      case(#Err(err)){
        ignore await* icrc1().mint(icrc1().minting_account().owner,  {
          to = request.to;               // The account receiving the newly minted tokens.
          amount =  request.amount;          // The number of tokens to mint.
          memo = ?Blob.fromArray([1,1,1,2,2,2,2]);               // An optional memo accompanying the minting operation.
          created_at_time = ?Nat64.fromNat(Int.abs(Time.now())); // The time the mint operation was created.
        });
         return #Err(#CallLedgerError{message = debug_show(err)});
      };
    };

    #Ok({
      txid = block;
      amount = request.amount;
    });
  };

  public query(msg) func icrc84_supported_tokens(prev: ?Token84, take: ?Nat) : async [Token84] {
    [#icrc1(Principal.fromText(CyclesLedger_CANISTER_ID))];
  };

  private func namespace_account(namespace: Text) : ICRC1.Account {
    {
          owner = Principal.fromActor(this);
          subaccount = ?Sha256.fromBlob(#sha256, Text.encodeUtf8(namespace));
    };
  };

  public query(msg) func icrc85_namespace_account(namespace: Text) : async ICRC1.Account{
    namespace_account(namespace);
  };

  ///MARK: ICRC84

  public query(msg) func icrc84_token_info(token: Token84) : async TokenInfo {
    if(token != #icrc1(Principal.fromText(CyclesLedger_CANISTER_ID))){ D.trap("UnknownToken")};
    {
      deposit_fee = 0; //deposit only supported through cmc
      withdrawal_fee = 100_000_000;
      min_deposit = 0;
      min_withdrawal = 100_000_000;
    };
  };

  public query(msg) func icrc84_credits(token: Token84) : async Int {
    if(token != #icrc1(Principal.fromText(CyclesLedger_CANISTER_ID))){ D.trap("UnknownToken")};
    icrc1().balance_of({owner = msg.caller; subaccount = null});
  };

  

  public query(msg) func icrc84_trackedDeposit(token: Token84) : async BalanceResult {
    if(token != #icrc1(Principal.fromText(CyclesLedger_CANISTER_ID))){ D.trap("UnknownToken")};
    #Ok(icrc1().balance_of({owner = msg.caller; subaccount = null}));
  };

  

  public query(msg) func icrc84_all_credits(prev: ?Token84, take: ?Nat) : async [(Token84, Int)] {
    [(#icrc1(Principal.fromText(CyclesLedger_CANISTER_ID)), icrc1().balance_of({owner = msg.caller; subaccount = null}))];
  };

  public shared(msg) func icrc84_notify(request: {token: Token84}) : async NotifyResult {
    #Err(#NotAvailable{message = "Deposits are only available through the icrc85_deposit_cycles function"});
  };

  public shared(msg) func icrc84_deposit(request: DepositArgs) : async DepositResponse {
    #Err(#TransferError{message = "Deposits are only available through the icrc85_deposit_cycles function"});
  };

  public shared(msg) func icrc84_withdraw(request: WithdrawArgs) : async WithdrawResult {
    debug if(debug_channel.announce) D.print("withdrawing cycles");

    assert(msg.caller == request.to.owner);

    assert(request.token == #icrc1(Principal.fromText(CyclesLedger_CANISTER_ID)));

    if(request.amount < 100_000_000){
      return #Err(#AmountBelowMinimum);
    };

    if(icrc1().balance_of(request.to) < (request.amount + 100_000_000)){
      return #Err(#InsufficientCredit);
    };

    //lockedAccounts
    //ignore ICRC1.Map.add(lockedAccounts, ICRC1.ahash, request.to, Int.abs(Time.now()));
    //todo: schedule timer to timeout

    //burn first
    let burnResult = icrc1().burn(icrc1().minting_account().owner, {
       from_subaccount = request.to.subaccount; // The subaccount from which tokens are burned.
       amount =  request.amount + 100_000_000;              // The number of tokens to burn.
       memo = null;                  // An optional memo accompanying the burn operation.
       created_at_time = ?Nat64.fromNat(Int.abs(Time.now()));
    });

    await withdraw_cycles(request);
  };

  ///MARK: ICRC75



  public type DataItemMap = Service75.DataItemMap;
  public type ManageRequest = Service75.ManageRequest;
  public type ManageResult = Service75.ManageResult;
  public type ManageListMembershipRequest = Service75.ManageListMembershipRequest;
  public type ManageListMembershipRequestItem = Service75.ManageListMembershipRequestItem;
  public type ManageListMembershipAction = Service75.ManageListMembershipAction;
  public type ManageListPropertyRequest = Service75.ManageListPropertyRequest;
  public type ManageListMembershipResponse = Service75.ManageListMembershipResponse;
  public type ManageListPropertyRequestItem = Service75.ManageListPropertyRequestItem;
  public type ManageListPropertyResponse = Service75.ManageListPropertyResponse;
  public type AuthorizedRequestItem = Service75.AuthorizedRequestItem;
  public type PermissionList = Service75.PermissionList;
  public type PermissionListItem = Service75.PermissionListItem;
  public type ListRecord = Service75.ListRecord;
  public type List = ICRC75.List;
  public type ListItem = ICRC75.ListItem;
  public type Permission = ICRC75.Permission;
  public type Identity = ICRC75.Identity;
  public type ManageResponse = Service75.ManageResponse;

  private func canChangeProperty<system>(trx: ICRC3.Value, trxtop: ?ICRC3.Value) : Result.Result<(ICRC3.Value, ?ICRC3.Value), Text> {

    debug if(debug_channel.announce) {
      D.print(debug_show(("In can update", trx, trxtop)));
    };
    switch(trxtop){
      case(?(val)){
        let ?#Text(bType) = ICRC3Helper.get_item_from_map("btype",val) else { return #err("Invalid Transaction")};
        if(bType == "75listCreate"){
          //make sure the caller is a controller on the domain
          let ?#Text(namespace) = ICRC3Helper.get_item_from_map("list", trx) else { return #err("Missing List")};
          let ?#Blob(creatorBlob) = ICRC3Helper.get_item_from_map("creator", trx) else { return #err("Missing Creator")};
          let creator = Principal.fromBlob(creatorBlob);
          let splitNamespace = Iter.toArray<Text>(Text.split(namespace, #text(".")));
          let domains = namespace_lookup([splitNamespace]);
          if(domains.size() == 0){
            return #err("Invalid Domain");
          };
          let ?foundDomain = domains[0] else return #err("Invalid Domain");
          let ?bFoundController = Array.indexOf<Principal>(creator, foundDomain.controllers, Principal.equal) else return #err("Unauthorized");

          //authorized, so we can continue
          return #ok((trx, trxtop));
        } else if(bType == "75listModify" ){
          let newName = ICRC3Helper.get_item_from_map("newName",val);
          switch(newName){
            case(?#Text(foundName)){
              let ?#Blob(callerBlob) = ICRC3Helper.get_item_from_map("caller",trx) else { return #err("Missing Caller")};
              let caller = Principal.fromBlob(callerBlob);
              let splitNamespace = Iter.toArray<Text>(Text.split(foundName, #text(".")));
              let domains = namespace_lookup([splitNamespace]);
              if(domains.size() == 0){
                return #err("Invalid Domain");
              };
              let ?foundDomain = domains[0] else return #err("Invalid Domain");
              let ?bFoundController = Array.indexOf<Principal>(caller, foundDomain.controllers, Principal.equal) else return #err("Unauthorized");
              return #ok((trx, trxtop));
            };
            case(_){};
          };

        } else if(bType == "75listDelete" ){

        } else if(bType == "75permChange" ){

        };
        return #ok((trx, trxtop));
      };
      case(_){
        return #err("Invalid Transaction");
      };
    };
    return #err("Invalid Transaction"); 
  };

  private func canChangeMembers<system>(trx: ICRC3.Value, trxtop: ?ICRC3.Value) : Result.Result<(ICRC3.Value, ?ICRC3.Value), Text> {
    switch(trxtop){
      case(?(val)){
        let ?#Text(bType) = ICRC3Helper.get_item_from_map("btype",val) else { return #err("Invalid Transaction")};
        if(bType == "75memChange"){
          //make sure the caller is a controller on the domain
          let ?#Text(namespace) = ICRC3Helper.get_item_from_map("list", trx) else { return #err("Missing List")};
          let ?#Text(action) = ICRC3Helper.get_item_from_map("change", trx) else { return #err("Missing Action")};

          let ?record = ICRC75.BTree.get(icrc75().get_state().namespaceStore, Text.compare, namespace) else return #err("Missing Namespace");

          if(action == "added" and ICRC75.Set.size(record.members) !=0){
            ICRC75.Set.clear(record.members); //only one entry allowed
            //replace if a valid entry
            let dataItem = switch(ICRC3Helper.get_item_from_map("accountItem", trx)){
              case(?#Array(val)){
                if(val.size() == 2){
                  switch(val[0], val[1]){
                    case(#Blob(blob), #Blob(subaccountBlob)){};
                    case(_){
                      return #err("Invalid Account Item")
                    };
                  };
                } else if (val.size() == 1){
                  switch(val[0]){
                    case(#Blob(blob)){};
                    case(_){
                      return #err("Invalid Account Item")
                    };
                  };
                } else return #err("Invalid Account Item");
              };
              case(_){
                return #err("Missing Account Item");
              };
            };
          } else return #err("Missing account");
            

          //authorized, so we can continue
          return #ok((trx, trxtop));
        } else return #err("Invalid Transaction");
      };
      case(_){
        return #err("Invalid Transaction" );
      };
    };
  };


  public query(msg) func icrc_75_metadata() : async DataItemMap {
    return icrc75().metadata();
  };

  public shared(msg) func icrc_75_manage(request: ManageRequest) : async ManageResponse {
      return icrc75().updateProperties(msg.caller, request);
    };

  public shared(msg) func icrc_75_manage_list_membership(request: ManageListMembershipRequest) : async ManageListMembershipResponse {
    return await* icrc75().manage_list_membership(msg.caller, request, ?#Sync(canChangeMembers));
  };

  public shared(msg) func icrc75_manage_list_properties(request: ManageListPropertyRequest) : async ManageListPropertyResponse {
    return await* icrc75().manage_list_properties(msg.caller, request, ?#Sync(canChangeProperty));
  };

  public query(msg) func icrc_75_get_lists(name: ?Text, includeArchived: Bool, cursor: ?List, limit: ?Nat) : async [ListRecord] {
    return icrc75().get_lists(msg.caller, name, includeArchived, cursor, limit);
  };

  public query(msg) func icrc_75_get_list_members_admin(list: List, cursor: ?ListItem, limit: ?Nat) : async [ListItem] {
    return icrc75().get_list_members_admin(msg.caller, list, cursor, limit);
  };

  public query(msg) func icrc_75_get_list_permissions_admin(list: List, filter: ?Permission, prev: ?PermissionListItem, take: ?Nat) : async PermissionList {
    return icrc75().get_list_permission_admin(msg.caller, list, filter, prev, take);
  };

  public query(msg) func icrc_75_get_list_lists(list: List, cursor: ?List, limit: ?Nat) : async [List] {
    return icrc75().get_list_lists(msg.caller, list, cursor, limit);
  };

  public query(msg) func icrc_75_member_of(listItem: ListItem, list: ?List, limit: ?Nat) : async [List] {
    return icrc75().member_of(msg.caller, listItem, list, limit);
  };

  public query(msg) func icrc_75_is_member(requestItems: [AuthorizedRequestItem]) : async [Bool] {
    return icrc75().is_member(msg.caller, requestItems);
  };

  system func postupgrade() {
    //re wire up the listener after upgrade
    //uncomment the following line to register the transfer_listener
      icrc1().register_token_transferred_listener("com.cycleshareledger", transfer_listener);

      icrc75().registerPropertyChangeListener("com.cycleshareledger", property_update_listener);

      icrc75().registerMembershipChangeListener("com.cycleshareledger", member_update_listener);

      //uncomment the following line to register the transfer_listener
      //icrc2().register_token_approved_listener("my_namespace", approval_listener);

      //uncomment the following line to register the transfer_listener
      //icrc1().register_transfer_from_listener("my_namespace", transfer_from_listener);
  };

};
